class Solution {
    public int[] solution(String[] info, String[] query) {
        Map&lt;String, List&lt;Integer&gt;&gt; infos = new HashMap&lt;&gt;();
        // info Map으로 정리
        for (String in : info) {
            String[] split = in.split(" ");
            int score = Integer.parseInt(split[4]);

            for (int i = 0; i &lt; (1 &lt;&lt; 4); i++) {
                StringBuilder key = new StringBuilder();
                // query의 '-'에 해당하는 부분집합(?) 만들기 위함
                for (int j = 0; j &lt; 4; j++) {
                    if ((i & (1 &lt;&lt; j)) &gt; 0)
                        key.append(split[j]);
                }
                // System.out.println(key.toString());
                infos.computeIfAbsent(key.toString(), s -&gt; new ArrayList&lt;&gt;()).add(score);
            }
        }

        // 정렬
        for (Map.Entry&lt;String, List&lt;Integer&gt;&gt; entry : infos.entrySet())
            entry.getValue().sort(null);

        int[] answer = new int[query.length];
        List&lt;Integer&gt; empty = new ArrayList&lt;&gt;();
        // query는 순서가 필요하므로 Map이 아닌 List 사용
        for (int i = 0; i &lt; query.length; i++) {
            // '-'를 공백(' ')으로, 그리고 스플릿 구분자를 ' and ', 혹은 ' '로 적용
            String[] split = query[i].replaceAll("-", "").split(" and | ");
            // StringBuilder와 String.join()의 차이는 뭘까?
            String key = String.join("", split[0], split[1], split[2], split[3]);
            int score = Integer.parseInt(split[4]);

            List&lt;Integer&gt; list = infos.getOrDefault(key, empty);

            // start point = s, end point = e
            int s = 0, e = list.size();
            while (s &lt; e) {
                // binary search를 위한 임시값
                // 초기값은 (0 + 리스트 길이)/2 로 중간값.
                int mid = (s + e) / 2;
                // mid번째 인덱스 값과 현재 검색해야할 score를 비교 후
                if (list.get(mid) &lt; score)
                    // 작다면, 시작점을 변경
                    s = mid + 1;
                else
                    // 크다면 종료점을 새로 설정 후 반복문 재실행
                    e = mid;
            }
            // 오름차순 정렬이기 때문에, 시작점에 해당하는 값을 빼면 score 이상 값을 포함한 개수를 반환한다.
            answer[i] = list.size() - s;
        }

        return answer;
    }
}